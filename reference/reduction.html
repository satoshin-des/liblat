<html>

<head>
    <title>liblat　関数レファレンスページ</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <style>
        @import url(style.css);
    </style>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
    <header>
        <h1 style="text-align:center">
            liblat　関数レファレンスページ
        </h1>
    </header>

    <h2>基底簡約関係関数</h2>
    <table>
        <tr>
            <th style="width:60px;"><a name="MaxLoop">宣言</a></th>
            <td style="color: yellow;">void setMaxLoop(const long max_loop);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                BKZやDeepBKZのツアー回数の上限を設定する
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>max_loop</td>
                        <td>：</td>
                        <td>ツアー回数の上限</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                BKZやDeepBKZのツアー回数の上限を設定する関数です．
                BKZアルゴリズムやDeepBKZアルゴリズムなどは停止性が保証されていないので，確実に停止させるにはツアー回数の上限を設定してあげる必要があります．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="DeepInsertion">宣言</a></th>
            <td style="color: yellow;">void deepInsertion(const long k, const long l);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                deep-insertionを行う
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>k</td>
                        <td>：</td>
                        <td>基底を挿入するインデックス</td>
                    </tr>
                    <tr>
                        <td>l</td>
                        <td>：</td>
                        <td>引き抜く基底のインデックス</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                基底にdeep-insertionを施す関数です．
                具体的には基底\(\lbrace\ldots,\boldsymbol{b}_k,\ldots,\boldsymbol{b}_\ell,\ldots\rbrace\)を\(\lbrace\ldots,\boldsymbol{b}_{k-1},\boldsymbol{b}_\ell,\boldsymbol{b}_k,\ldots,\boldsymbol{b}_{\ell-1},\boldsymbol{b}_{\ell+1},\ldots\rbrace\)に変換します．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="DualDeepInsertion">宣言</a></th>
            <td style="color: yellow;">void dualDeepInsertion(const long k, const long l);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                双対型deep-insertionを行う
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>k</td>
                        <td>：</td>
                        <td>引き抜く基底のインデックス</td>
                    </tr>
                    <tr>
                        <td>l</td>
                        <td>：</td>
                        <td>基底を挿入するインデックス</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                基底に双対型deep-insertionを施す関数です．
                具体的には基底\(\lbrace\ldots,\boldsymbol{b}_k,\ldots,\boldsymbol{b}_\ell,\ldots\rbrace\)を\(\lbrace\ldots,\boldsymbol{b}_{k-1},\boldsymbol{b}_{k+1},\ldots,\boldsymbol{b}_{\ell},\boldsymbol{b}_{k},\boldsymbol{b}_{\ell+1},\ldots\rbrace\)に変換します．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="updateDeep">宣言</a></th>
            <td style="color: yellow;">void updateDeepInsGSO(const long i, const long k, const long start, const long
                end);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                deep-insertionを施した後のGSO情報の効率的な更新
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>i</td>
                        <td>：</td>
                        <td>引き抜く基底のインデックス</td>
                    </tr>
                    <tr>
                        <td>k</td>
                        <td>：</td>
                        <td>基底を挿入するインデックス</td>
                    </tr>
                    <tr>
                        <td>start</td>
                        <td>：</td>
                        <td>deep-insertionを格子基底の一部に施す際，その開始インデックス</td>
                    </tr>
                    <tr>
                        <td>end</td>
                        <td>：</td>
                        <td>deep-insertionを格子基底の一部に施す際，その終了インデックス</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                基底にdeep-insertionを施した後のGSO情報の更新を効率的に行う関数です．
                <a
                    href="fund.html#GSO">computeGSO</a>関数を用いてGSO情報を更新することも可能ですが，効率的ではない上に誤差が出やすいのでこの関数を用いて更新することを強くおすすめします．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="updateDualDeep">宣言</a></th>
            <td style="color: yellow;">void updateDualDeepInsGSO(const long k, const long l, const std::vector<double> dual_D);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                双対型deep-insertionを施した後のGSO情報の効率的な更新
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>i</td>
                        <td>：</td>
                        <td>引き抜く基底のインデックス</td>
                    </tr>
                    <tr>
                        <td>k</td>
                        <td>：</td>
                        <td>基底を挿入するインデックス</td>
                    </tr>
                    <tr>
                        <td>start</td>
                        <td>：</td>
                        <td>deep-insertionを格子基底の一部に施す際，その開始インデックス</td>
                    </tr>
                    <tr>
                        <td>end</td>
                        <td>：</td>
                        <td>deep-insertionを格子基底の一部に施す際，その終了インデックス</td>
                    </tr>
                    <tr>
                        <td>dual_D</td>
                        <td>：</td>
                        <td></td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                基底に双対型deep-insertionを施した後のGSO情報の更新を効率的に行う関数です．
                <a
                    href="fund.html#GSO">computeGSO</a>関数を用いてGSO情報を更新することも可能ですが，効率的ではない上に誤差が出やすいのでこの関数を用いて更新することを強くおすすめします．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="size">宣言</a></th>
            <td style="color: yellow;">void sizeReduce(const bool compute_gso = true);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                サイズ基底簡約
                <br>
                <a
                    href="https://www.amazon.co.jp/%E6%A0%BC%E5%AD%90%E6%9A%97%E5%8F%B7%E8%A7%A3%E8%AA%AD%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E6%95%B0%E5%AD%A6%E7%9A%84%E5%9F%BA%E7%A4%8E-IMI%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E9%80%B2%E5%8C%96%E3%81%99%E3%82%8B%E7%94%A3%E6%A5%AD%E6%95%B0%E5%AD%A6-%E9%9D%92%E9%87%8E-%E8%89%AF%E7%AF%84/dp/4764905981">Y.
                    Aono, M. Yasuda. 格子暗号解読のための数学的基礎.(2019)</a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)をサイズ基底簡約する関数です．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="LLL">宣言</a></th>
            <td style="color: yellow;">void LLL(const double delta = 0.75, const bool compute_gso = true, const long
                start_ = 0, const long end_ = -1);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                LLL基底簡約
                <br>
                <a href="https://link.springer.com/article/10.1007/BF01457454">A. K. Lenstra, H. W. Lenstra, L. Lovasz.
                    Factoring polynomials with rational coefficients.(1982)</a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>delta</td>
                        <td>：</td>
                        <td>簡約パラメータ（0.75以上1以下）</td>
                    </tr>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                    <tr>
                        <td>start_</td>
                        <td>：</td>
                        <td>LLL簡約を基底の一部分にのみ行う場合，その開始インデックス</td>
                    </tr>
                    <tr>
                        <td>end_</td>
                        <td>：</td>
                        <td>LLL簡約を基底の一部分にのみ行う場合，その終了インデックス</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)に対して，その部分格子基底\(\lbrace\boldsymbol{b}_{\texttt{start_}+1}, \ldots,
                \boldsymbol{b}_\texttt{end_}\rbrace\)を簡約パラメータdeltaに関してLLL簡約する関数です．
            </td>
        </tr>
    </table>
<pre class="code_block"><code>#include &lt;iostream&gt;
#include "lattice.h"
        
int main()
{
    // 40次正方行列を基底行列に持つ格子
    Lattice lat(40, 40);
        
    // ランダムなSVP型格子に設定
    lat.setRandom(40, 40, 1000, 9999);
            
    // LLL基底簡約
    lat.LLL(0.99);

    // 基底行列の表示
    std::cout &lt;&lt; lat &lt;&lt; std::endl;
        
    return 0;
}</code></pre>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="DeepLLL">宣言</a></th>
            <td style="color: yellow;">void deepLLL(const double delta = 0.75, const bool compute_gso = true, const long
                start_ = 0, const long end_ = -1);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                DeepLLL基底簡約
                <br>
                <a href="https://link.springer.com/article/10.1007/BF01581144">
                    C. P. Schnorr, M. Euchner. Lattice basis
                    reduction: Improved practical algorithms and solving subset sum
                    problem.(1994)
                </a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>delta</td>
                        <td>：</td>
                        <td>簡約パラメータ（0.75以上1以下）</td>
                    </tr>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                    <tr>
                        <td>start_</td>
                        <td>：</td>
                        <td>DeepLLL簡約を基底の一部分にのみ行う場合，その開始インデックス</td>
                    </tr>
                    <tr>
                        <td>end_</td>
                        <td>：</td>
                        <td>DeepLLL簡約を基底の一部分にのみ行う場合，その終了インデックス</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)に対して，その部分格子基底\(\lbrace\boldsymbol{b}_{\texttt{start_}+1}, \ldots,
                \boldsymbol{b}_\texttt{end_}\rbrace\)を簡約パラメータdeltaに関してDeepLLL簡約する関数です．
            </td>
        </tr>
    </table>
<pre class="code_block"><code>#include &lt;iostream&gt;
#include "lattice.h"
        
int main()
{
    // 40次正方行列を基底行列に持つ格子
    Lattice lat(40, 40);
        
    // ランダムなSVP型格子に設定
    lat.setRandom(40, 40, 1000, 9999);
            
    // DeepLLL基底簡約
    lat.deepLLL(0.99);

    // 基底行列の表示
    std::cout &lt;&lt; lat &lt;&lt; std::endl;
        
    return 0;
}</code></pre>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="PotLLL">宣言</a></th>
            <td style="color: yellow;">void potLLL(const double delta = 0.75, const bool compute_gso = true);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                PotLLL基底簡約
                <br>
                <a href="https://link.springer.com/article/10.1007/s10623-014-9918-8">F. Fontein, M. Schneider, U.
                    Wagner. PotLLL: A polynomial time version of LLL with deep
                    insertions.(2014)
                </a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>delta</td>
                        <td>：</td>
                        <td>簡約パラメータ（0.75以上1以下）</td>
                    </tr>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)を簡約パラメータdeltaに関してPotLLL簡約する関数です．
            </td>
        </tr>
    </table>
<pre class="code_block"><code>#include &lt;iostream&gt;
#include "lattice.h"
        
int main()
{
    // 40次正方行列を基底行列に持つ格子
    Lattice lat(40, 40);
        
    // ランダムなSVP型格子に設定
    lat.setRandom(40, 40, 1000, 9999);
            
    // LLL基底簡約
    lat.potLLL(0.99);

    // 基底行列の表示
    std::cout &lt;&lt; lat &lt;&lt; std::endl;
        
    return 0;
}</code></pre>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="BKZ">宣言</a></th>
            <td style="color: yellow;">void BKZ(const long beta, const double delta = 0.75, const bool compute_gso =
                true);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                BKZ基底簡約
                <br>
                <a href="https://link.springer.com/article/10.1007/BF01581144">C. P. Schnorr, M. Euchner. Lattice basis
                    reduction: Improved practical algorithms and solving subset sum problem.(1994)
                </a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>beta</td>
                        <td>：</td>
                        <td>ブロックサイズ（2以上格子次元以下）</td>
                    </tr>
                    <tr>
                        <td>delta</td>
                        <td>：</td>
                        <td>簡約パラメータ（0.75以上1以下）</td>
                    </tr>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)をブロックサイズbetaと簡約パラメータdeltaに関してBKZ簡約する関数です．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="HKZ">宣言</a></th>
            <td style="color: yellow;">void HKZ(const double delta = 0.75, const bool compute_gso = true);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                HKZ基底簡約
                <br>
                <a href="https://link.springer.com/article/10.1007/BF01442912">A. Korkine, G. Zolotareff. Sur les formes
                    quadratiques positives ternaires.(1872)</a>
                <br>
                <a href="https://link.springer.com/article/10.1007/BF01442795">A. Korkine, G. Zolotareff. Sur les formes
                    quadratiques.(1873)</a>
                <br>
                <a href="https://link.springer.com/article/10.1007/BF01581144">C. P. Schnorr, M. Euchner. Lattice basis
                    reduction: Improved practical algorithms and solving subset sum problem.(1994)
                </a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>delta</td>
                        <td>：</td>
                        <td>簡約パラメータ（0.75以上1以下）</td>
                    </tr>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)を簡約パラメータdeltaに関してHKZ簡約する関数です．
                <br>
                具体的には，格子基底を格子次元と同じ大きさのブロックサイズに関してBKZ基底簡約します．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="DeepBKZ">宣言</a></th>
            <td style="color: yellow;">void deepBKZ(const long beta, const double delta = 0.75, const bool compute_gso =
                true);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                DeepBKZ基底簡約
                <br>
                <a href="https://link.springer.com/chapter/10.1007/978-3-319-76620-1_9">J. Yamaguchi, M. Yasuda.
                    Explicit formula for Gram-Schmidt vectors in LLL with deep insertions and its applications.(2017)
                </a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>beta</td>
                        <td>：</td>
                        <td>ブロックサイズ（2以上格子次元以下）</td>
                    </tr>
                    <tr>
                        <td>delta</td>
                        <td>：</td>
                        <td>簡約パラメータ（0.75以上1以下）</td>
                    </tr>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)をブロックサイズbetaと簡約パラメータdeltaに関してDeepBKZ簡約する関数です．
                <br>
                具体的には，BKZアルゴリズムのサブルーチンとして使っているLLLの代わりにDeepLLLを使用することによって実現しています．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="PotBKZ">宣言</a></th>
            <td style="color: yellow;">void potBKZ(const long beta, const double delta = 0.75, const bool compute_gso =
                true);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                PotBKZ基底簡約
                <br>
                <a href="https://www.iwsec.org/scis/2025/program.html#2D2">A. Sato, M. Yasuda.
                    自己双対型PotBKZ基底簡約の提案とBKZとの比較.(2025)
                </a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>beta</td>
                        <td>：</td>
                        <td>ブロックサイズ（2以上格子次元以下）</td>
                    </tr>
                    <tr>
                        <td>delta</td>
                        <td>：</td>
                        <td>簡約パラメータ（0.75以上1以下）</td>
                    </tr>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)をブロックサイズbetaと簡約パラメータdeltaに関してPotBKZ簡約する関数です．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="DualDeepLLL">宣言</a></th>
            <td style="color: yellow;">void dualDeepLLL(const double delta = 0.75, const bool compute_gso = true);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                双対型DeepLLL基底簡約
                <br>
                <a href="https://link.springer.com/chapter/10.1007/978-3-319-89339-6_10">M. Yasuda, J. Yamaguchi, M.
                    Ooka, S. Nakamura. Development of a dual version of DeepBKZ and its application to solving the LWE
                    challenge.(2018)
                </a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>delta</td>
                        <td>：</td>
                        <td>簡約パラメータ（0.75以上1以下）</td>
                    </tr>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)を簡約パラメータdeltaに関して双対型DeepLLL簡約する関数です．
            </td>
        </tr>
    </table>
    <br>
    <hr style="color: white;">
    <br>
    <table>
        <tr>
            <th style="width:60px;"><a name="DualPotLLL">宣言</a></th>
            <td style="color: yellow;">void dualPotLLL(const double delta = 0.75, const bool compute_gso = true);</td>
        </tr>
        <tr>
            <th style="width:60px;">概略</th>
            <td>
                双対型PotLLL基底簡約
                <br>
                <a href="https://www.iwsec.org/scis/2025/program.html#2D2">A. Sato, M. Yasuda.
                    自己双対型PotBKZ基底簡約の提案とBKZとの比較.(2025)
                </a>
            </td>
        </tr>
        <tr>
            <th style="width:60px;">引数</th>
            <td>
                <table>
                    <tr>
                        <td>delta</td>
                        <td>：</td>
                        <td>簡約パラメータ（0.75以上1以下）</td>
                    </tr>
                    <tr>
                        <td>compute_gso</td>
                        <td>：</td>
                        <td>簡約する前にGSO情報を更新するか．<br>事前にGSO情報を計算していない場合はtrueにする必要がある</td>
                    </tr>
                </table>
            </td>
        </tr>
        <tr>
            <th style="width: 40px;">戻り値</th>
            <td>なし</td>
        </tr>
        <tr>
            <th style="width:60px;">解説</th>
            <td>
                格子基底\(\lbrace\boldsymbol{b}_1, \ldots,
                \boldsymbol{b}_n\rbrace\)を簡約パラメータdeltaに関して双対型PotLLL簡約する関数です．
            </td>
        </tr>
    </table>

    <footer style="text-align: center;">
        <p>Copyright © 2024 さとしん All Rights Reserved.</p>
    </footer>
</body>

</html>